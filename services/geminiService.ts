import { GoogleGenAI, Modality } from "@google/genai";
import type { GenerateContentResponse } from "@google/genai";

const API_KEY_STORAGE_KEY = 'gemini-api-key';

// This function will be the single source for getting an initialized client.
const getGeminiClient = () => {
    const apiKey = localStorage.getItem(API_KEY_STORAGE_KEY);
    if (!apiKey) {
        throw new Error("API 金鑰未設定。請在第一步中輸入您的 API 金鑰。");
    }
    return new GoogleGenAI({ apiKey });
};


const getBase64Parts = (base64Data: string) => {
  const match = base64Data.match(/^data:(image\/\w+);base64,(.*)$/);
  if (!match) {
    throw new Error('Invalid base64 string');
  }
  return { mimeType: match[1], data: match[2] };
};

const extractImageFromResponse = (response: GenerateContentResponse): string => {
    for (const part of response.candidates[0].content.parts) {
      if (part.inlineData) {
          return `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
      }
    }
    throw new Error('No image was generated by the API.');
}

// A wrapper for generateContent that includes retry logic for rate limiting errors.
const generateContentWithRetry = async (
    params: any, // Simplified type for internal use
    onStatusUpdate?: (status: string) => void
): Promise<GenerateContentResponse> => {
    const ai = getGeminiClient();
    const maxRetries = 3;

    for (let i = 0; i < maxRetries; i++) {
        try {
            return await ai.models.generateContent(params);
        } catch (err: any) {
            if (err instanceof Error && err.message) {
                try {
                    const errorResponse = JSON.parse(err.message);
                    // Check for rate limit error (429)
                    if (errorResponse.error?.code === 429) {
                        // Specifically check if it's a daily quota limit, which is not retryable.
                        const violations = errorResponse.error.details?.flatMap((d: any) => d.violations || []);
                        const isDailyQuota = violations.some((v: any) => v.quotaId?.includes('PerDay'));

                        if (isDailyQuota) {
                            // Throw a specific, user-friendly error immediately.
                            throw new Error("您已達到今日的免費使用上限。請明天再試，或為您的 Google Cloud 專案啟用計費以解除限制。");
                        }
                        
                        // If it's another type of rate limit and we haven't exhausted retries, proceed.
                        if (i < maxRetries - 1) {
                            const retryInfo = errorResponse.error.details?.find((d: any) => d['@type'] === 'type.googleapis.com/google.rpc.RetryInfo');
                            let retryAfter = Math.pow(2, i) * 5; // Default exponential backoff (5s, 10s)
                            
                            if (retryInfo?.retryDelay) {
                                retryAfter = parseInt(retryInfo.retryDelay.replace('s', ''));
                            }
                            
                            onStatusUpdate?.(`已達請求上限。將在 ${retryAfter} 秒後重試 (${i + 1}/${maxRetries - 1})...`);
                            await new Promise(res => setTimeout(res, retryAfter * 1000));
                            onStatusUpdate?.('正在重試...');
                            continue; // Continue to the next iteration of the loop to retry
                        }
                    }
                } catch (e: any) {
                    // This inner catch will grab our custom daily quota error and re-throw it.
                    // It will also catch non-JSON parse errors. In either case, we stop.
                    throw e;
                }
            }
            // Rethrow if it's not a parsable rate-limit error or if retries are exhausted
            throw err;
        }
    }
    // This should not be reached if maxRetries > 0, but is a safeguard.
    throw new Error('AI 請求在多次重試後失敗。');
};

export const cleanImage = async (base64Image: string, onStatusUpdate?: (status: string) => void): Promise<string> => {
  const { mimeType, data } = getBase64Parts(base64Image);
  const prompt = `Your task is to be a hyper-realistic digital staging expert. Your goal is to completely empty the room in this photo, leaving only its fundamental architectural structure. You must remove **everything** that is not part of the building itself. This includes:
- All furniture (sofas, chairs, tables, beds, cabinets, etc.).
- All appliances, whether freestanding or built-in (TVs, refrigerators, lamps, speakers).
- All decorations and personal items (rugs, plants, books, photos).
- **Crucially, remove all objects attached to the walls, ceiling, or floor.** This includes wall art, clocks, mirrors, wall-mounted shelves, light fixtures, sconces, curtains and their rods.
The final image must be a photorealistic depiction of a completely vacant room, showing only the floor, walls, ceiling, windows, and doors. Seamlessly reconstruct the underlying surfaces, perfectly matching the original lighting, shadows, and textures. The room should look as if it has been completely cleared out for a new occupant.`;
  
  const response = await generateContentWithRetry({
      model: 'gemini-2.5-flash-image-preview',
      contents: {
          parts: [
              { inlineData: { data, mimeType } },
              { text: prompt },
          ],
      },
      config: {
          responseModalities: [Modality.IMAGE, Modality.TEXT],
      },
  }, onStatusUpdate);

  return extractImageFromResponse(response);
};

export const furnishImage = async (base64Image: string, itemsPrompt: string, onStatusUpdate?: (status: string) => void): Promise<string> => {
  const { mimeType, data } = getBase64Parts(base64Image);
  const fullPrompt = `Using this image of an empty room as a base, add the following items according to the descriptions:\n${itemsPrompt}\n\nDo not add any other items. Generate a photorealistic image of the furnished room. The lighting and shadows of the new items should match the room's existing lighting.`;
  
  const response = await generateContentWithRetry({
      model: 'gemini-2.5-flash-image-preview',
      contents: {
          parts: [
              { inlineData: { data, mimeType } },
              { text: fullPrompt },
          ],
      },
      config: {
          responseModalities: [Modality.IMAGE, Modality.TEXT],
      },
  }, onStatusUpdate);

  return extractImageFromResponse(response);
};